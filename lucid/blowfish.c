/* Calculate centroid of a peak in pedestal histogram
 *
 */
#include <math.h>

void
calcent(data, size, cent, sigma, error, num, maxchan, max)
  long *size;
  float *cent, *sigma, *error, *num;
  short *maxchan, *max;
  long data[];
{
  short i,j;
  double sum,sig,x,tot;
  short start,stop;
  short DSIZE;

  DSIZE = *size;
  *max = 0;
  *maxchan = DSIZE/2;
  for(j=0; j<DSIZE; j++)
    if(data[j] > *max )
    {
      *max = data[j];
      *maxchan = j;
    }
  *sigma = 100.;
  for(i=0; i<2; i++)
  {
    if(*sigma == 0.) break;
    start = *maxchan - (int) (*sigma * 3);
    stop = *maxchan + (int) (*sigma * 3);
    if(start < 0 ) start = 0;
    if(stop >= DSIZE) stop = DSIZE - 1;
    sum = 0.;
    sig = 0.;
    tot = 0.;
    for(j = start; j <= stop; j++)
    {
      x = j + 0.5;
      tot += data[j];
      sum += x * data[j];
      sig += x * x * data[j];
    }
    if( tot > 0)
    {
      *cent = sum / tot ;
      *sigma = sqrt( sig/tot - *cent * *cent);
      *error = *sigma / sqrt(tot);
      *num = tot;
    }
    else
    {
      *cent = 0.;
      *sigma = 0.;
      *error = 0.;
      *num = 0.;
    }
  }
  return;
}

#include <stdio.h>

void calc_psd_rotation(float *m_targ, int *base_psd, 
    int *peak0, int *ph0, int *peak1, int *ph1, 
    int *offset, float *rot)
  /* Given the the peak locations for the upper (_1) and lower (_0) bands
   * along with the band midpoint (in pulse height) adjust the old
   * rotation (shear) and offset values to give the (peak,ph) pairs 
   * the slope m_targ and base location base_psd. */ 
{
  if( *ph1 == *ph0 ) {
    printf("calc_psd_rotation: ph1=ph0\n");
    return;
  }
  if( *m_targ == 0 ){
    printf("calc_psd_rotation: m_targ=0\n");
    return;
  }

  /* Remove the previously applied offset from peak positions */
  *peak0 -= *offset;
  *peak1 -= *offset;

  /* Remove the old shear */
  *peak0 += *rot * *ph0;
  *peak1 += *rot * *ph1;

  /* calculate the new shear */
  *rot = 1.0/(*ph1 - *ph0) * ( *peak1 - *peak0 - (*ph1 - *ph0)/ *m_targ );
  
  /* calculate the new offset */
  *offset = *base_psd - (*peak0 - (*rot * *ph0));


}
#define PEDSUBMAX 100
#define PEDSUBMID 50
#define PEDMAXDRIFT 2
#define PEDMAXCOUNTERR 50
void
checkped(long *pedsub, long *count, long *shift, long *diff)
	{
	/* Quick check of pedestal shift for online use.
	 * Simple maximum channel peak search.
	 * The pedsub histogram should have maximum channel
	 * at channel PEDSUBMID.
	 */
	int i, sum, maxchan, max;

	*shift = 0;
	*diff = 0;

	max = 0;
	maxchan = 0;
	sum = 0;
	for(i = 0; i < PEDSUBMAX; i++)
		{
		sum += pedsub[i];
		if(pedsub[i] > max)
			{
			max = pedsub[i];
			maxchan = i;
			}
		}
	if(sum < *count - PEDMAXCOUNTERR) *diff = *count - sum;
	if(maxchan > PEDSUBMID + PEDMAXDRIFT ||
	   maxchan < PEDSUBMID - PEDMAXDRIFT ) *shift = maxchan - PEDSUBMID;
	}
#undef PEDSUBMAX
#undef PEDSUBMID
#undef PEDMAXDRIFT
#undef PEDMAXCOUNTERR
#include <time.h>
#include <string.h>

void
convert_time(clock, date)
  long *clock;
  char *date;
{
  long cl;
  if(*clock == 0) cl = time(0);
  else		cl = *clock;
  strcpy(date,ctime(&cl));
  date[24] = '\0';
}

#include <stdio.h>
#include <stdlib.h>
/* 
 * This program is intended to accept a list of integers-encoded text
 * generated by caget.pl (which have been stored in the LUCID data
 * stream).  caget_decode.pl converts those integers back into text and
 * writes the result to stdout.
 */

void
decode_caget(long array[], long *arrlen) {
  int   i, j, bufflen, charPerInt;
  char  *word, *buffer;

  usleep( 100000 );  /* sleep 100 ms */

  bufflen = *arrlen * sizeof(long);

  if( (buffer = (char *)malloc(bufflen+1) ) == NULL ) {
    fprintf(stderr,"decode_caget: !! Cannot allocate buffer.\n");
    exit(1);
  }

  j=0;
  for(i=0;i<*arrlen;i++) {
    if(array[i] != 0) {
      word = (char *)(array+i);  /* relies on long=4bytes=4chars */
      sprintf(buffer+j,"%c%c%c%c",word[0],word[1],word[2],word[3]);
      j+=4;
    }
  }
  buffer[j]='\0'; /* terminate buffer string */
  printf("\n%s\n",buffer);
  free(buffer);
}
#define TYPE_MASK 0x7
#define TYPE_SHIFT 24
#define CHANNEL_MASK 0x3f
#define CHANNEL_SHIFT 16
#define DATA_MASK 0xfff

void
decode_vme(long *vmedata, long *numvme, short *array, long *narray,
		short *buffers, short *notvalid )
	/* Un packing the vme data which has been compressed 
	 * using the "Daron Chabot" method.
	 */
	{
	int i;
	int type, channel;

	*buffers = 0;
	*notvalid = 0;
	for(i = 0; i < *narray; i++) array[i] = 0;
	for(i = 0; i < *numvme; i++)
		{
		type = (vmedata[i] >> TYPE_SHIFT) & TYPE_MASK;
		if(type == 2) (*buffers)++;
		if(type == 0 && vmedata[i] != 0)
			{
			channel = (vmedata[i] >> CHANNEL_SHIFT) & CHANNEL_MASK;
			if(channel < *narray) array[channel] = vmedata[i] & DATA_MASK;
			}
		if(type == 6) (*notvalid)++;
		}
	}

#undef TYPE_MASK
#undef TYPE_SHIFT
#undef CHANNEL_MASK
#undef CHANNEL_SHIFT
#undef DATA_MASK
/*######################
  ## findMax.c
  ######################*/
/* Take an array of ints, y[0-n] and return the location of the
 * maximum in peak */

void findMax(unsigned int *y, int *n, int *peak)
{
  int   i, max;
  int   maxchan;

  max=0;
  maxchan=0;
  for(i=0; i<*n; i++) {
    if(*(y+i) > max) {
      maxchan = i;
      max     = *(y+i);
    }
  }
  *peak = maxchan;
}
#define DEBUG 0

#define MAXARRAYSIZE 4096
#define MAXCHANNEL 3500
#define MINCHANNEL 800
#define SMOOTHBIN 36
#define MAXSMOOTH (MAXARRAYSIZE/SMOOTHBIN+1)
#define MINCOUNTPERCHANNEL 0.5
#define MINSLOPEPERCHANNEL (5.0)
// (factional counts)/1000 channels at channel 1000
#define NSLOPE 2
#define FSLOPE 1.0
#define AHEADCHECK 4
#define FSTART 0.82
#define FSTOP 1.18
#define MAXFIT ((MAXCHANNEL-MINCHANNEL)/SMOOTHBIN+1)
#define FWIDTH 0.1
#define NPAR 5

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
/*
 *    *** fitedge ***
 * Subroutine to find a compton edge
 * to be called from the LUCID looker
 *
 * It is ASSUMED that the histogram pointed to by *array
 *    array = <histogram_name>
 * was defined in the looker by
 *    define <histogram_name> histogram from <from> to 4096 (<bins> bins)
 * or define <histogram_name> histogram from <from> to 4096 (binsize <binsize>)
 * or define <histogram_name> histogram first <from> last 4095 (<bins> bins)
 * or define <histogram_name> histogram first <from> last 4095 (binsize <binsize>)
 * then you must set: *binwid = (4096-<from>)/<bins>
 *                 OR *binwid = <binsize> 
 * and you must set:  *offset = <from>
 * The histogram must be a integer*4 histogram (the lucid default)
 *
 * Only the region between *start and *stop is checked for an edge.
 * These are in 0 to 4096 units as are the returned values
 *     *edge is the inflection point
 *     *edgeerr is the error in *edge from the fit
 *
 * There must be at least an average of MINCOUNTPERCHANNEL counts
 * per (4096) channel in the region of the edge to find an edge
 * 
 */


double Edge_function( double x, double *a)
	{
	double v;
	v = a[0] + x*a[1];
	v += a[2] * erfc((x - a[3])/a[4]);
	return(v);
	}

double Edge_slope( double * x, double * y, double *dy, int ic);

void
searchfit(double *x, double *y, double *dy, int num, int npar,
	double (*funpointer) (),
	double *a, double *step, double *anew, double *danew);

void
fitedge(long *array, long *offset, long *binwid, long *start, long *stop,
	float *edge, float *edgeerr)
	{
	// fit a source compton edge
	// return the edge centre and error
	double x[MAXSMOOTH], y[MAXSMOOTH], dy[MAXSMOOTH];
	double xf[MAXFIT], yf[MAXFIT], dyf[MAXFIT];
	int i,j,n,imax,iedge, smoothbin;
	int found;
	double sl, osl, slj, integral, countperchannel, diff, intbins;
	double max, ym, xedge, yedge, dyedge, xwid, mincount;
	double a[NPAR], da[NPAR], afit[NPAR], afiterr[NPAR];
	double (*funpointer)(double , double *);
	FILE *fp;
	
	// The function we want to fit in the call to searchfit()
	funpointer = &Edge_function;
	// first smooth the spectrum by binning
	if(DEBUG) printf("Offset = %d Binwidth = %d\n", *offset, *binwid);

	smoothbin = SMOOTHBIN / (*binwid);
	xwid = smoothbin * (*binwid);
	j = 0;
	x[0] = *offset + xwid/2.0 + 0.5;
	y[0] = 0;
	for(i = 0; i < MAXARRAYSIZE; i++)
		{
		if(i < smoothbin*(j+1))
			{
			y[j] += array[i];
			}
		else
			{
			if(j+1 >= MAXSMOOTH) break;
			if(x[j] + xwid > MAXCHANNEL ) break;
			j++;
			x[j] = x[j-1] + xwid;
			y[j] = array[i];
			}
		}
	n = j+1;
	j = 0;
	integral = 0;
	intbins = 0.;
	for(i=0; i < n; i++)
		{
		if(x[i] < MINCHANNEL) continue;
		x[j] = x[i];
		y[j] = y[i];
		dy[j] = sqrt(y[i]);
		if(x[j] >= *start && x[j] <= *stop)
			{
			intbins += xwid;
			integral += y[j];
			}
		j++;
		}
	n = j;
	if(DEBUG>2)
	{
	printf("Smoothed spectrum, n = %d\n",n);
	for(i=0; i < n; i++)
		{
		printf("%.1f: ",x[i]);
		for(;(i+1)%8 != 0; i++) printf(" %.1f+-%.1f",y[i],dy[i]);
		printf("\n");
		}
	}
	if(DEBUG)
	{
	// write a file with the smoothed spectrum
	fp = fopen("smooth.dat", "w");
	for(i=0; i < n; i++)
		{
		fprintf(fp, "%g\t%g\t%g\n", x[i], y[i],dy[i]);
		}
	fclose(fp);
	}
	// Now attempt to find a maximum slope from the top down
	max = MINSLOPEPERCHANNEL * integral / intbins * xwid / (*stop + *start) *2;
	mincount = MINCOUNTPERCHANNEL * xwid;
	if(DEBUG)
		{
		printf("Fit region from %d to %d\n",*start, *stop);
		printf("Integral = %.0f\n",integral);
		printf("Average counts per channel = %.2f\n",integral/intbins);
		printf("Minimum slope = %.2g\n", max);
		printf("Minimum count = %.0f\n", mincount);
		}
	found = 0;
	iedge = 0;
	osl = Edge_slope(x,y,dy,i);
	i = n-NSLOPE-1;
	while(--i > AHEADCHECK)
		{
		if(x[i] < *start || x[i] > *stop) continue;
		sl = Edge_slope(x, y, dy, i);
		if(DEBUG) printf("At x[%d] = %.1f y = %.0f slope = %.2g\n",i,x[i],y[i],sl);
		if(sl >= max && y[i] > mincount)
			{
			max = sl;
			found = 1;
			if(DEBUG>1)printf("     MAX i = %d max = %.2g\n",i,max);
			}
		else if(found && sl < osl)
			{
			// check ahead to see if any of the next AHEADCHECK
			// is greater than max - if not we will assume
			// we have a local maximum in the slope
			iedge = 1;
			for(j=i-1; j>i-1-AHEADCHECK; j--)
				{
				slj = Edge_slope(x,y,dy,j);
				if(DEBUG>1)printf("Ahead j = %d, slj = %.2g\n",j,slj);
				if(slj > max)
					{
					iedge = 0;
					max = slj;
					sl = slj;
					i = j;
					if(DEBUG>1)printf("     MAX i = %d max = %.2g\n",i,max);
					break;
					}
				}
			if(iedge)
				{
				iedge = i+1;
				break;
				}
			}
		osl = sl;
		}
	if(iedge == 0)
		{
		// no edge found or not enought statistics for a fit
		*edge = 0;
		*edgeerr = 0;
		return;
		}
	if(DEBUG)
	{
	printf("Edge found at x[%d] = %f y = %f\n",iedge, x[iedge], y[iedge]);
	}
	// now find a fit to a range around this edge
	// from FSTART*x[iedge] to FSTOP*x[iedge]
	xedge = x[iedge];
	yedge = y[iedge];
	dyedge = dy[iedge];
	j = 0;
	for(i=0; i < n-1; i++)
		{
		if(x[i] >= FSTART*xedge)
			{
			if( x[i] > FSTOP*xedge ) break;
			xf[j] = x[i];
			yf[j] = y[i];
			dyf[j] = dy[i];
			if(j++ >= MAXFIT)break;
			}
		}
	if(DEBUG>2)
	{
	printf("Fit range: num = %d\n",j);
	for(i=0; i < j; i++)
		{
		printf("%.1f:  %.1f +- %.1f\n",xf[i], yf[i], dyf[i]);
		}
	}
	
	// initial guess of parameters
	a[0] = yf[j-1];
	da[0] = dyf[j-1];
	a[1] = 0;
	da[1] = dyf[0] / xwid;
	a[2] = yf[0]/2.0;
	da[2] = dyf[0]/2.0;
	a[3] = xedge;
	da[3] = xwid/10.;
	a[4] = FWIDTH*xedge;
	da[4] = xwid/10.;

	searchfit(xf, yf, dyf, j, NPAR, funpointer, a, da, afit, afiterr);

	// If result is outside fit range - give up!
	if(afit[3] < xf[0] || afit[3] > xf[j-1])
		{
		*edge = 0.0;
		*edgeerr = 0.0;
		return;
		}
	// final check - see if found edge is resonably close to
	// centre of fit range - if not, fit again to perhaps improve the fit
	diff = fabs(xedge - afit[3]);
	if( diff > (x[j-1] - x[0]) * 0.25)
		{
		xedge = afit[3];
		if(DEBUG) printf("Redoing fit: diff = %f\n",diff);
		// redo fit
		j = 0;
		for(i=0; i < n-1; i++)
			{
			if(x[i] >= FSTART*xedge)
				{
				if( x[i] > FSTOP*xedge ) break;
				xf[j] = x[i];
				yf[j] = y[i];
				dyf[j] = dy[i];
				if(j++ >= MAXFIT)break;
				}
			}
		a[3] = xedge;
		searchfit(xf, yf, dyf, j, NPAR, funpointer, a, da, afit, afiterr);
		}

	if(afit[3] < xf[0] || afit[3] > xf[j-1] || afiterr[3] <= 0.0)
		{
		*edge = 0.0;
		*edgeerr = 0.0;
		}
	else
		{
		*edge = afit[3];
		*edgeerr = afiterr[3];
		}
	}

double Edge_slope( double * x, double * y, double *dy, int ic)
	{
	// average slope calculated using the +-NSLOPE points around ic
	// (actually calculate negative slope)
	int i, j;
	double sum_wy, sum_wxy, sum_w, sum_wx, sum_wx2;
	double delta, w, s, se;

	sum_wy = 0;
	sum_wxy = 0;
	sum_w = 0;
	sum_wx = 0;
	sum_wx2 = 0;
	for(i=ic-NSLOPE; i <= ic+NSLOPE-1; i++)
		{
		if(dy[i] > 0)
			w = 1.0/dy[i]/dy[i];
		else
			w = 0;
		sum_w += w;
		sum_wx += w*x[i];
		sum_wx2 += w*x[i]*x[i];
		sum_wy += w*y[i];
		sum_wxy += w*y[i]*x[i];
		}
	delta = sum_w * sum_wx2 - sum_wx * sum_wx;
	if(delta == 0.) return (0.);
	s = -(sum_w * sum_wxy - sum_wx * sum_wy) / delta;
	se = sqrt( sum_w / delta );
	// require that the slope be 'significant'
	// i.e. that -slope > FSLOPE*(error in slope)
	if(DEBUG>1) printf("    Edge_slope(): ic = %d s = %g se = %g\n",ic,s,se);
	if(s < FSLOPE*se)return (0.0);
	else return (s);
	
	}
#undef DEBUG
#undef MAXARRAYSIZE
#undef MAXCHANNEL
#undef MINCHANNEL
#undef SMOOTHBIN
#undef MAXSMOOTH
#undef MINCOUNTPERCHANNEL
#undef MINSLOPEPERCHANNEL
#undef NSLOPE
#undef FSLOPE
#undef AHEADCHECK
#undef FSTART
#undef FSTOP
#undef MAXFIT
#undef FWIDTH
#undef NPAR
#define DEBUG 0

#define STDFIT 4.0
#define MINCOUNT 10

#include <math.h>

void
fitflash(long *array, long *bins, long *offset, long *binwid,
	long *start, long *stop,
	float *peak, float *peakerr, float *stdev, float *stdeverr)
	{
	// find a flasher peak
	// return the peak centre and error
	int i;
	double xpeak, a;
	double tot, sum, sig, xpeakerr, sigma, sigmaerr;
	int istart, istop;
	int again;
	
	istart = (*start - *offset) / (*binwid);
	if(istart < 0) istart = 0;
	istop = (*stop - *offset) / (*binwid);
	if(istop >= *bins) istop = *bins;
	again = 2;

	if(DEBUG)printf("Bins = %d offset = %d, binwidth = %d\n", *bins, *offset, *binwid);

	// Repeat twice - first on whole spectrum
	//              - second in region +- STDFIT*sigma around peak
	while(again--)
	{
	// Now find mean and standard deviation
	sum = 0.0;
	sig = 0.0;
	tot = 0.0;
	if(DEBUG)printf("start = %d, stop = %d\n",istart, istop);
	for(i = istart; i < istop; i++)
		{
		tot += array[i];
		a = i*array[i];
		sum += a;
		sig += i*a;
		}
	if(tot > MINCOUNT)
		{
		xpeak = sum / tot;
		sigma = sqrt((sig - sum*sum/tot)/(tot-1.0));
		}
	else
		{
		// no peak found or not enought statistics for a fit
		*peak = 0;
		*peakerr = 0;
		*stdev = 0;
		*stdeverr = 0;
		return;
		}
	if(DEBUG)
		{
		printf("Mean =  %.1f Standard deviation = %.1f\n",
		xpeak, sigma);
		}
	istart = xpeak - STDFIT*sigma;
	if(istart < 1 ) istart = 1;
	istop = xpeak + STDFIT*sigma + 1;
	if(istop > *bins) istop = *bins;
	}

	xpeakerr = sigma / sqrt(tot);
	sigmaerr = sigma / sqrt(2*(tot-1.0));
	if(DEBUG)
		{
		printf("Mean =  %.1f +- %.1f Standard deviation = %.1f +- %.1f\n",
		xpeak, xpeakerr, sigma, sigmaerr);
		}

	*peak = (xpeak + 0.5) * (*binwid) + *offset;
	*peakerr = xpeakerr * (*binwid);
	*stdev = sigma * (*binwid);
	*stdeverr = sigmaerr * (*binwid);
	}
#undef DEBUG
#undef STDFIT
#undef MINCOUNT
#define DEBUG 0

#define MAXARRAYSIZE 4096
#define SMOOTHBIN 36
#define MAXSMOOTH (MAXARRAYSIZE/SMOOTHBIN+1)
#define MINPEAK (SMOOTHBIN*2)
#define AHEADCHECK 4
#define FSTART 0.64
#define FSTOP 1.16
#define FWIDTH 0.1
#define NPAR 6

#include <stdlib.h>
#include <stdio.h>
#include <math.h>


double Source_function( double x, double *a)
	{
	double Source_gaussian(double, double, double, double);
	double v;
	v = Source_gaussian(x, a[0], a[1], a[2]);
	v += Source_gaussian(x, a[3], a[4], a[5]);
	return(v);
	}
double Source_gaussian(double x, double amax, double cent, double sig)
	{
	double g = amax * exp( -(x-cent)*(x-cent) / (2.0*sig*sig) );
	return(g);
	}
void
searchfit(double *x, double *y, double *dy, int num, int npar,
	double (*funpointer) (),
	double *a, double *step, double *anew, double *danew);
// --------------------------------------------------------------
void
fitsource(long *array, long *bins, long *offset, long *binwid,
	long *start, long *stop,
	float *peak, float *peakerr, float *stdev, float *stdeverr)
	{
	// fit a monitor or flasher peak
	// return the peak centre and error
	double x[MAXSMOOTH], y[MAXSMOOTH], dy[MAXSMOOTH];
	int i,j,n,imax,ipeak, smoothbin;
	int found;
	double max, ym, xpeak, ypeak, dypeak, xwid;
	double a[NPAR], da[NPAR], afit[NPAR], afiterr[NPAR];
	double (*funpointer) ();
	FILE *fp;
	
	// The function we want to fit in the call to searchfit
	funpointer = *Source_function;
	// first smooth the spectrum by binning
	if(DEBUG) printf("Bins = %d offset = %d binwidth = %d\n", *bins, *offset, *binwid);

	smoothbin = SMOOTHBIN / (*binwid);
	xwid = smoothbin * (*binwid);
	j = 0;
	x[0] = xwid/2.0 + (*offset) + 0.5;
	y[0] = 0;
	for(i = 0; i < *bins; i++)
		{
		if(i < smoothbin*(j+1))
			{
			y[j] += array[i];
			}
		else
			{
			if(j+1 >= MAXSMOOTH) break;
			j++;
			x[j] = x[j-1] + xwid;
			y[j] = array[i];
			}
		}
	n = j+1;
	if(DEBUG>2)
	{
	printf("Smoothed spectrum, n = %d\n",n);
	for(i=0; i < n; i++)
		{
		printf("%.1f: ",x[i]);
		for(;(i+1)%8 != 0; i++) printf(" %.1f",y[i]);
		printf("\n");
		}
	}
	if(DEBUG)
	{
	// write a file with the smoothed spectrum
	fp = fopen("smooth.dat", "w");
	for(i=0; i < n; i++)
		{
		fprintf(fp, "%g\t%g\n", x[i], y[i]);
		}
	fclose(fp);
	}

	// Now attempt to find a peak from the top down
	// first find a local peak
	i = n;
	max = MINPEAK;
	found = 0;
	ipeak = 0;
	if(DEBUG) printf("n = %d max = %f\n",n,max);
	while(--i > AHEADCHECK)
		{
		if(x[i] < *start || x[i] > *stop) continue;
		if(DEBUG > 1) printf("x[%d] = %f, y = %f, max = %f\n",i,x[i],y[i],max);
		if(y[i] >= max)
			{
			max = y[i];
			found = 1;
			}
		else if(found && y[i] < y[i+1])
			{
			// check ahead to see if any of the next AHEADCHECK
			// is greater than max - if not we will assume
			// we have a local maximum
			ipeak = 1;
			for(j=i-1; j>i-1-AHEADCHECK; j--)
				{
				if(y[j] > max)
					{
					ipeak = 0;
					max = y[j];
					i = j;
					break;
					}
				}
			if(ipeak)
				{
				ipeak = i+1;
				break;
				}
			}
		}
	if(ipeak == 0)
		{
		// no peak found or not enought statistics for a fit
		*peak = 0;
		*peakerr = 0;
		*stdev = 0;
		*stdeverr = 0;
		if(DEBUG) printf("No peak found\n");
		return;
		}
	if(DEBUG)
	{
	printf("Peak found at ipeak = %d x[ipeak] = %f y[ipeak] = %f\n",ipeak, x[ipeak], y[ipeak]);
	}
	// now find a fit to a range around this peak
	// from FSTART*x[ipeak] to FSTOP*x[ipeak]
	xpeak = x[ipeak];
	ypeak = y[ipeak];
	dypeak = sqrt(ypeak);
	j = 0;
	for(i=0; i < n; i++)
		{
		if(x[i] >= FSTART*x[ipeak] && x[i] <= FSTOP*x[ipeak])
			{
			x[j] = x[i];
			y[j] = y[i];
			dy[j] = sqrt(y[i]);
			j++;
			}
		}
	if(DEBUG>2)
	{
	printf("Fit range: num = %d\n",j);
	for(i=0; i < j; i++)
		{
		printf("%.1f:  %.1f +- %.1f\n",x[i], y[i], dy[i]);
		}
	}
	
	// initial guess of parameters
	a[3] = ypeak;
	da[3] = dypeak;
	a[4] = xpeak;
	da[4] = xwid/10.0;
	a[5] = FWIDTH*xpeak;
	da[5] = xwid/10.0;
	a[0] = y[0];
	da[0] = dy[0];
	a[1] = x[0];
	da[1] = da[4];
	a[2] = a[5];
	da[2] = da[5];

	searchfit(x, y, dy, j, NPAR, funpointer, a, da, afit, afiterr);

	if(afiterr[4] > 0.)
		{
		*peak = afit[4];
		*peakerr = afiterr[4];
		*stdev = afit[5];
		*stdeverr = afiterr[5];
		}
	else
		{
		*peak = 0.;
		*peakerr = 0.;
		*stdev = 0.;
		*stdeverr = 0.;
		if(DEBUG) printf("No peak found\n");
		}
	}

#undef DEBUG
#undef MAXARRAYSIZE
#undef SMOOTHBIN
#undef MAXSMOOTH
#undef MINPEAK
#undef AHEADCHECK
#undef FSTART
#undef FSTOP
#undef FWIDTH
#undef NPAR
/*######################
## four1.c
######################*/
#include <math.h>
#define SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr

void four1(float data[], unsigned long nn, int isign)
{
  unsigned long n,mmax,m,j,istep,i;
  double wtemp,wr,wpr,wpi,wi,theta;
  float tempr,tempi;

  n=nn << 1;
  j=1;
  for (i=1;i<n;i+=2) {
    if (j > i) {
      SWAP(data[j],data[i]);
      SWAP(data[j+1],data[i+1]);
    }
    m=n >> 1;
    while (m >= 2 && j > m) {
      j -= m;
      m >>= 1;
    }
    j += m;
  }
  mmax=2;
  while (n > mmax) {
    istep=mmax << 1;
    theta=isign*(6.28318530717959/mmax);
    wtemp=sin(0.5*theta);
    wpr = -2.0*wtemp*wtemp;
    wpi=sin(theta);
    wr=1.0;
    wi=0.0;
    for (m=1;m<mmax;m+=2) {
      for (i=m;i<=n;i+=istep) {
        j=i+mmax;
        tempr=wr*data[j]-wi*data[j+1];
        tempi=wr*data[j+1]+wi*data[j];
        data[j]=data[i]-tempr;
        data[j+1]=data[i+1]-tempi;
        data[i] += tempr;
        data[i+1] += tempi;
      }
      wr=(wtemp=wr)*wpr-wi*wpi+wr;
      wi=wi*wpr+wtemp*wpi+wi;
    }
    mmax=istep;
  }
}
#undef SWAP
/* (C) Copr. 1986-92 Numerical Recipes Software *t9,12. */
/*######################
  ## make_filename.c
  ######################*/
#include <stdio.h>
#include <stdlib.h>
#define DEBUG 0
/* This routine generates a filename of the form <prefix1><prefix2><run#>.<suffix> */

void
make_filename(char *filename, char *prefix1, char *prefix2, int *runNum, char *suffix)
{
  int i;
  FILE *inP;
  

  sprintf(filename,"%s%s%.4d.%s",prefix1,prefix2,*runNum,suffix);
  if(DEBUG) printf("Looking for name: %s\n", filename);
 
  /* if this initial check fails (ie. file doesn't exist) we can use the name */
  if( (inP=fopen(filename,"r")) == NULL ) { 
    if(DEBUG) printf("*** Found useable name: %s\n", filename);
    return;
  }
  fclose(inP);
  
  /* otherwise append a number and check again */
  i=1;
  do {
    sprintf(filename,"%s%s%.4d.%s.%.2d",prefix1,prefix2,*runNum,suffix,i);
    if(DEBUG) printf("Looking for name: %s\n", filename);
    if( (inP=fopen(filename,"r")) == NULL ) { /* if it fails we can use the name */
      if(DEBUG) printf("*** Found useable name: %s\n", filename);
      return;
    }
    fclose(inP);
    i++;
  }
  while(i<100);
  
  printf("make_filename: Can't open a file for \"%s%s%.4d.%s\".\n",
		prefix1,prefix2,*runNum,suffix);
  return;
}
#undef DEBUG
/*######################
## nrutil.c
######################*/
#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#define NR_END 1
#define FREE_ARG char*

void nrerror(char error_text[])
  /* Numerical Recipes standard error handler */
{
  fprintf(stderr,"Numerical Recipes run-time error...\n");
  fprintf(stderr,"%s\n",error_text);
  fprintf(stderr,"...now exiting to system...\n");
  exit(1);
}

float *vector(long nl, long nh)
  /* allocate a float vector with subscript range v[nl..nh] */
{
  float *v;

  v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));
  if (!v) nrerror("allocation failure in vector()");
  return v-nl+NR_END;
}

int *ivector(long nl, long nh)
  /* allocate an int vector with subscript range v[nl..nh] */
{
  int *v;

  v=(int *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(int)));
  if (!v) nrerror("allocation failure in ivector()");
  return v-nl+NR_END;
}

unsigned char *cvector(long nl, long nh)
  /* allocate an unsigned char vector with subscript range v[nl..nh] */
{
  unsigned char *v;

  v=(unsigned char *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
  if (!v) nrerror("allocation failure in cvector()");
  return v-nl+NR_END;
}

unsigned long *lvector(long nl, long nh)
  /* allocate an unsigned long vector with subscript range v[nl..nh] */
{
  unsigned long *v;

  v=(unsigned long *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(long)));
  if (!v) nrerror("allocation failure in lvector()");
  return v-nl+NR_END;
}

double *dvector(long nl, long nh)
  /* allocate a double vector with subscript range v[nl..nh] */
{
  double *v;

  v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));
  if (!v) nrerror("allocation failure in dvector()");
  return v-nl+NR_END;
}

float **matrix(long nrl, long nrh, long ncl, long nch)
  /* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
{
  long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
  float **m;

  /* allocate pointers to rows */
  m=(float **) malloc((size_t)((nrow+NR_END)*sizeof(float*)));
  if (!m) nrerror("allocation failure 1 in matrix()");
  m += NR_END;
  m -= nrl;

  /* allocate rows and set pointers to them */
  m[nrl]=(float *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float)));
  if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
  m[nrl] += NR_END;
  m[nrl] -= ncl;

  for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

double **dmatrix(long nrl, long nrh, long ncl, long nch)
  /* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
{
  long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
  double **m;

  /* allocate pointers to rows */
  m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));
  if (!m) nrerror("allocation failure 1 in matrix()");
  m += NR_END;
  m -= nrl;

  /* allocate rows and set pointers to them */
  m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));
  if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
  m[nrl] += NR_END;
  m[nrl] -= ncl;

  for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

int **imatrix(long nrl, long nrh, long ncl, long nch)
  /* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
{
  long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
  int **m;

  /* allocate pointers to rows */
  m=(int **) malloc((size_t)((nrow+NR_END)*sizeof(int*)));
  if (!m) nrerror("allocation failure 1 in matrix()");
  m += NR_END;
  m -= nrl;


  /* allocate rows and set pointers to them */
  m[nrl]=(int *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(int)));
  if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
  m[nrl] += NR_END;
  m[nrl] -= ncl;

  for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
    long newrl, long newcl)
/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
{
  long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
  float **m;

  /* allocate array of pointers to rows */
  m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
  if (!m) nrerror("allocation failure in submatrix()");
  m += NR_END;
  m -= newrl;

  /* set pointers to rows */
  for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch)
  /* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
     declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
     and ncol=nch-ncl+1. The routine should be called with the address
     &a[0][0] as the first argument. */
{
  long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
  float **m;

  /* allocate pointers to rows */
  m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
  if (!m) nrerror("allocation failure in convert_matrix()");
  m += NR_END;
  m -= nrl;

  /* set pointers to rows */
  m[nrl]=a-ncl;
  for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
  /* return pointer to array of pointers to rows */
  return m;
}

float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh)
  /* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
{
  long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
  float ***t;

  /* allocate pointers to pointers to rows */
  t=(float ***) malloc((size_t)((nrow+NR_END)*sizeof(float**)));
  if (!t) nrerror("allocation failure 1 in f3tensor()");
  t += NR_END;
  t -= nrl;

  /* allocate pointers to rows and set pointers to them */
  t[nrl]=(float **) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float*)));
  if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
  t[nrl] += NR_END;
  t[nrl] -= ncl;

  /* allocate rows and set pointers to them */
  t[nrl][ncl]=(float *) malloc((size_t)((nrow*ncol*ndep+NR_END)*sizeof(float)));
  if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
  t[nrl][ncl] += NR_END;
  t[nrl][ncl] -= ndl;

  for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
  for(i=nrl+1;i<=nrh;i++) {
    t[i]=t[i-1]+ncol;
    t[i][ncl]=t[i-1][ncl]+ncol*ndep;
    for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
  }

  /* return pointer to array of pointers to rows */
  return t;
}

void free_vector(float *v, long nl, long nh)
  /* free a float vector allocated with vector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_ivector(int *v, long nl, long nh)
  /* free an int vector allocated with ivector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_cvector(unsigned char *v, long nl, long nh)
  /* free an unsigned char vector allocated with cvector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_lvector(unsigned long *v, long nl, long nh)
  /* free an unsigned long vector allocated with lvector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_dvector(double *v, long nl, long nh)
  /* free a double vector allocated with dvector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_matrix(float **m, long nrl, long nrh, long ncl, long nch)
  /* free a float matrix allocated by matrix() */
{
  free((FREE_ARG) (m[nrl]+ncl-NR_END));
  free((FREE_ARG) (m+nrl-NR_END));
}

void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)
  /* free a double matrix allocated by dmatrix() */
{
  free((FREE_ARG) (m[nrl]+ncl-NR_END));
  free((FREE_ARG) (m+nrl-NR_END));
}

void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch)
  /* free an int matrix allocated by imatrix() */
{
  free((FREE_ARG) (m[nrl]+ncl-NR_END));
  free((FREE_ARG) (m+nrl-NR_END));
}

void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch)
  /* free a submatrix allocated by submatrix() */
{
  free((FREE_ARG) (b+nrl-NR_END));
}

void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch)
  /* free a matrix allocated by convert_matrix() */
{
  free((FREE_ARG) (b+nrl-NR_END));
}

void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
    long ndl, long ndh)
/* free a float f3tensor allocated by f3tensor() */
{
  free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
  free((FREE_ARG) (t[nrl]+ncl-NR_END));
  free((FREE_ARG) (t+nrl-NR_END));
}

#else /* ANSI */
/* traditional - K&R */

#include <stdio.h>
#define NR_END 1
#define FREE_ARG char*

void nrerror(error_text)
  char error_text[];
  /* Numerical Recipes standard error handler */
{
  void exit();

  fprintf(stderr,"Numerical Recipes run-time error...\n");
  fprintf(stderr,"%s\n",error_text);
  fprintf(stderr,"...now exiting to system...\n");
  exit(1);
}

float *vector(nl,nh)
  long nh,nl;
  /* allocate a float vector with subscript range v[nl..nh] */
{
  float *v;

  v=(float *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(float)));
  if (!v) nrerror("allocation failure in vector()");
  return v-nl+NR_END;
}

int *ivector(nl,nh)
  long nh,nl;
  /* allocate an int vector with subscript range v[nl..nh] */
{
  int *v;

  v=(int *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(int)));
  if (!v) nrerror("allocation failure in ivector()");
  return v-nl+NR_END;
}

unsigned char *cvector(nl,nh)
  long nh,nl;
  /* allocate an unsigned char vector with subscript range v[nl..nh] */
{
  unsigned char *v;

  v=(unsigned char *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
  if (!v) nrerror("allocation failure in cvector()");
  return v-nl+NR_END;
}

unsigned long *lvector(nl,nh)
  long nh,nl;
  /* allocate an unsigned long vector with subscript range v[nl..nh] */
{
  unsigned long *v;

  v=(unsigned long *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(long)));
  if (!v) nrerror("allocation failure in lvector()");
  return v-nl+NR_END;
}

double *dvector(nl,nh)
  long nh,nl;
  /* allocate a double vector with subscript range v[nl..nh] */
{
  double *v;

  v=(double *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(double)));
  if (!v) nrerror("allocation failure in dvector()");
  return v-nl+NR_END;
}

float **matrix(nrl,nrh,ncl,nch)
  long nch,ncl,nrh,nrl;
  /* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
{
  long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
  float **m;

  /* allocate pointers to rows */
  m=(float **) malloc((unsigned int)((nrow+NR_END)*sizeof(float*)));
  if (!m) nrerror("allocation failure 1 in matrix()");
  m += NR_END;
  m -= nrl;

  /* allocate rows and set pointers to them */
  m[nrl]=(float *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(float)));
  if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
  m[nrl] += NR_END;
  m[nrl] -= ncl;

  for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

double **dmatrix(nrl,nrh,ncl,nch)
  long nch,ncl,nrh,nrl;
  /* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
{
  long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
  double **m;

  /* allocate pointers to rows */
  m=(double **) malloc((unsigned int)((nrow+NR_END)*sizeof(double*)));
  if (!m) nrerror("allocation failure 1 in matrix()");
  m += NR_END;
  m -= nrl;

  /* allocate rows and set pointers to them */
  m[nrl]=(double *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(double)));
  if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
  m[nrl] += NR_END;
  m[nrl] -= ncl;

  for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

int **imatrix(nrl,nrh,ncl,nch)
  long nch,ncl,nrh,nrl;
  /* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
{
  long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
  int **m;

  /* allocate pointers to rows */
  m=(int **) malloc((unsigned int)((nrow+NR_END)*sizeof(int*)));
  if (!m) nrerror("allocation failure 1 in matrix()");
  m += NR_END;
  m -= nrl;


  /* allocate rows and set pointers to them */
  m[nrl]=(int *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(int)));
  if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
  m[nrl] += NR_END;
  m[nrl] -= ncl;

  for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

float **submatrix(a,oldrl,oldrh,oldcl,oldch,newrl,newcl)
  float **a;
  long newcl,newrl,oldch,oldcl,oldrh,oldrl;
  /* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
{
  long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
  float **m;

  /* allocate array of pointers to rows */
  m=(float **) malloc((unsigned int) ((nrow+NR_END)*sizeof(float*)));
  if (!m) nrerror("allocation failure in submatrix()");
  m += NR_END;
  m -= newrl;

  /* set pointers to rows */
  for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;

  /* return pointer to array of pointers to rows */
  return m;
}

float **convert_matrix(a,nrl,nrh,ncl,nch)
  float *a;
  long nch,ncl,nrh,nrl;
  /* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
     declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
     and ncol=nch-ncl+1. The routine should be called with the address
     &a[0][0] as the first argument. */
{
  long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
  float **m;

  /* allocate pointers to rows */
  m=(float **) malloc((unsigned int) ((nrow+NR_END)*sizeof(float*)));
  if (!m)	nrerror("allocation failure in convert_matrix()");
  m += NR_END;
  m -= nrl;

  /* set pointers to rows */
  m[nrl]=a-ncl;
  for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
  /* return pointer to array of pointers to rows */
  return m;
}

float ***f3tensor(nrl,nrh,ncl,nch,ndl,ndh)
  long nch,ncl,ndh,ndl,nrh,nrl;
  /* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
{
  long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
  float ***t;

  /* allocate pointers to pointers to rows */
  t=(float ***) malloc((unsigned int)((nrow+NR_END)*sizeof(float**)));
  if (!t) nrerror("allocation failure 1 in f3tensor()");
  t += NR_END;
  t -= nrl;

  /* allocate pointers to rows and set pointers to them */
  t[nrl]=(float **) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(float*)));
  if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
  t[nrl] += NR_END;
  t[nrl] -= ncl;

  /* allocate rows and set pointers to them */
  t[nrl][ncl]=(float *) malloc((unsigned int)((nrow*ncol*ndep+NR_END)*sizeof(float)));
  if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
  t[nrl][ncl] += NR_END;
  t[nrl][ncl] -= ndl;

  for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
  for(i=nrl+1;i<=nrh;i++) {
    t[i]=t[i-1]+ncol;
    t[i][ncl]=t[i-1][ncl]+ncol*ndep;
    for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
  }

  /* return pointer to array of pointers to rows */
  return t;
}

void free_vector(v,nl,nh)
  float *v;
  long nh,nl;
  /* free a float vector allocated with vector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_ivector(v,nl,nh)
  int *v;
  long nh,nl;
  /* free an int vector allocated with ivector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_cvector(v,nl,nh)
  long nh,nl;
  unsigned char *v;
  /* free an unsigned char vector allocated with cvector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_lvector(v,nl,nh)
  long nh,nl;
  unsigned long *v;
  /* free an unsigned long vector allocated with lvector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_dvector(v,nl,nh)
  double *v;
  long nh,nl;
  /* free a double vector allocated with dvector() */
{
  free((FREE_ARG) (v+nl-NR_END));
}

void free_matrix(m,nrl,nrh,ncl,nch)
  float **m;
  long nch,ncl,nrh,nrl;
  /* free a float matrix allocated by matrix() */
{
  free((FREE_ARG) (m[nrl]+ncl-NR_END));
  free((FREE_ARG) (m+nrl-NR_END));
}

void free_dmatrix(m,nrl,nrh,ncl,nch)
  double **m;
  long nch,ncl,nrh,nrl;
  /* free a double matrix allocated by dmatrix() */
{
  free((FREE_ARG) (m[nrl]+ncl-NR_END));
  free((FREE_ARG) (m+nrl-NR_END));
}

void free_imatrix(m,nrl,nrh,ncl,nch)
  int **m;
  long nch,ncl,nrh,nrl;
  /* free an int matrix allocated by imatrix() */
{
  free((FREE_ARG) (m[nrl]+ncl-NR_END));
  free((FREE_ARG) (m+nrl-NR_END));
}

void free_submatrix(b,nrl,nrh,ncl,nch)
  float **b;
  long nch,ncl,nrh,nrl;
  /* free a submatrix allocated by submatrix() */
{
  free((FREE_ARG) (b+nrl-NR_END));
}

void free_convert_matrix(b,nrl,nrh,ncl,nch)
  float **b;
  long nch,ncl,nrh,nrl;
  /* free a matrix allocated by convert_matrix() */
{
  free((FREE_ARG) (b+nrl-NR_END));
}

void free_f3tensor(t,nrl,nrh,ncl,nch,ndl,ndh)
  float ***t;
  long nch,ncl,ndh,ndl,nrh,nrl;
  /* free a float f3tensor allocated by f3tensor() */
{
  free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
  free((FREE_ARG) (t[nrl]+ncl-NR_END));
  free((FREE_ARG) (t+nrl-NR_END));
}

#endif /* ANSI */
#include <stdio.h>
#define NUM_PER_RING 8
void
print_array_int(long *start, long *stop, long array[], char *filename) {
  int i, j, arrlen, diskFile;
  FILE       *outF;

  arrlen = *stop - *start + 1;
  diskFile=0;
  usleep( 100000 );  /* sleep 100 ms */

//  fprintf(stderr, "print_array_int: %d\t%d\t%d\n",*start, *stop, arrlen);
  if( filename[0] != '\0' ) {
    if( (outF = fopen( filename, "a")) == NULL) {
      printf("Can't open file '%s' for output\n",filename);
      return;
      }
    diskFile = 1;
  } else {
    outF = stdout;
  }
  if(arrlen > NUM_PER_RING) fprintf(outF,"\n");
  j=0;
  for(i=*start; i<=*stop; i++) {
    fprintf(outF,"%8d",array[i]);
    if( j%NUM_PER_RING == NUM_PER_RING-1 ) fprintf(outF,"\n");
    j++;
  }
  if( arrlen%NUM_PER_RING != 0 ) fprintf(outF,"\n");
  if(diskFile) fclose(outF);
}

#undef NUM_PER_RING
#include <stdio.h>
#define NUM_PER_RING 8
void
print_array_real(long *start, long *stop, float array[], char *filename) {
  int i, j, arrlen, diskFile;
  FILE       *outF;

  arrlen = *stop - *start + 1;
  diskFile = 0;
  usleep( 100000 );  /* sleep 100 ms */

  //fprintf(stderr, "print_array_real: %d\t%d\t%d\n",*start, *stop, arrlen);
  if( filename[0] != '\0' ) {
    if( (outF = fopen( filename, "a")) == NULL) {
      printf("Can't open file '%s' for output\n",filename);
      return;
      }
    diskFile = 1;
  } else {
    outF = stdout;
  }
  if(arrlen > NUM_PER_RING) fprintf(outF,"\n");
  j=0;
  for(i=*start; i<=*stop; i++) {
    fprintf(outF,"%8.1f",array[i]);
    if( j%NUM_PER_RING == NUM_PER_RING-1 ) fprintf(outF,"\n");
    j++;
  }
  if( arrlen%NUM_PER_RING != 0 ) fprintf(outF,"\n");
  if(diskFile) fclose(outF);
}

#undef NUM_PER_RING
/*######################
## print_run_nums.c
######################*/
/* Prints out a list of processed run files */
/*   If fileName="" then prints to stdout.  */
/*   runlist[] is assumed to terminate with a zero entry */
#include <stdio.h>
#include <stdlib.h>
#define MAXINDEX 100

void print_run_nums(int runlist[], char *fileName)
{
  int i,toFile;
  FILE *outP;

  usleep( 100000 );  /* sleep 100 ms */
  if(strlen(fileName)==0) toFile=0; else toFile=1;

  if(toFile) {
    if((outP=fopen(fileName,"a")) == NULL ) {
      perror(fileName);
      exit(8);
    }
    fprintf(outP,"#");
  } else {
    outP=stdout;
    fprintf(outP,"-- ");
  }

  fprintf(outP,"Processed runs: ");
  for(i=0; i<MAXINDEX; i++) {
    if( runlist[i] == 0 ) { break; }
    fprintf(outP,"%d   ",runlist[i]);
  }
  fprintf(outP,"\n");

  if(toFile) fclose(outP);

  return;
}
#undef MAXINDEX
/*######################
## realft.c
######################*/
#include <math.h>

void realft(float data[], unsigned long n, int isign)
{
  void four1(float data[], unsigned long nn, int isign);
  unsigned long i,i1,i2,i3,i4,np3;
  float c1=0.5,c2,h1r,h1i,h2r,h2i;
  double wr,wi,wpr,wpi,wtemp,theta;

  theta=3.141592653589793/(double) (n>>1);
  if (isign == 1) {
    c2 = -0.5;
    four1(data,n>>1,1);
  } else {
    c2=0.5;
    theta = -theta;
  }
  wtemp=sin(0.5*theta);
  wpr = -2.0*wtemp*wtemp;
  wpi=sin(theta);
  wr=1.0+wpr;
  wi=wpi;
  np3=n+3;
  for (i=2;i<=(n>>2);i++) {
    i4=1+(i3=np3-(i2=1+(i1=i+i-1)));
    h1r=c1*(data[i1]+data[i3]);
    h1i=c1*(data[i2]-data[i4]);
    h2r = -c2*(data[i2]+data[i4]);
    h2i=c2*(data[i1]-data[i3]);
    data[i1]=h1r+wr*h2r-wi*h2i;
    data[i2]=h1i+wr*h2i+wi*h2r;
    data[i3]=h1r-wr*h2r+wi*h2i;
    data[i4] = -h1i+wr*h2i+wi*h2r;
    wr=(wtemp=wr)*wpr-wi*wpi+wr;
    wi=wi*wpr+wtemp*wpi+wi;
  }
  if (isign == 1) {
    data[1] = (h1r=data[1])+data[2];
    data[2] = h1r-data[2];
  } else {
    data[1]=c1*((h1r=data[1])+data[2]);
    data[2]=c1*(h1r-data[2]);
    four1(data,n>>1,-1);
  }
}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define NUMOUT 100
#define DEBUG 0

double search(int num, double *x, double *y, double *dy,
	double (*funpointer) (), int npar, double *a, double *stepin,
	double *anew);
double chisq( int num, double *x, double*y, double*dy,
	double (*funpointer) (), double *a);
//
// General fitting routine that uses a simple search algorithm
//   Originally written in fortran in c1979 (Rob Pywell)
//   C version 2000-2004
//
// The function to be fitted is y = f(x, a)
//   where a is an array of parameters
//   The pointer (funpointer = &f) points to this function
// Searchfit takes as npar initial guesses for the parameters (a)
// and an initial search step for each parameter (step)
//   The search step will be decreased as necessary to reduce
//   the error in the fitted paramaters.
// The fitted parameters (anew) and there errors (danew) are returned
//
void
searchfit(double *x, double *y, double *dy, int num, int npar,
	double (*funpointer) (),
	double *a, double *step, double *anew, double *danew)
	{
	int i, j, numpar;
	int redo;
	double ch0, ch1, tmp;
	double chi, redchi;
	double xmin, xmax, xout, yout;
	FILE *fp;

	// parameters of the fit
	numpar = npar;
	for(i=0; i < npar; i++)
		{
		if(step[i] == 0) numpar--;
		}

	if(DEBUG>2)
		{
		printf( "Number of Data Points = %d\n", num);
		for(i=0; i<num; i++)
			{
			printf( "%f  %f  %f\n", x[i], y[i], dy[i] );
			}
		}
	
	// start of loop until step < error
	do {

	if(DEBUG)
		{
		printf("\nParameter initial guesses:\n");
		for(i=0; i<npar; i++)
			{
			printf("a[%d] = %f step %f\n", i, a[i], step[i]);
			}
		}

	// Calculate the initial chisq
	chi = chisq( num, x, y, dy, funpointer, a);

	if(DEBUG)
		{
		printf("Chi-squared of initial guesses = %f\n", chi);
		redchi = chi / (num - numpar);
		printf("Reduced chi-squared = %f\n", redchi);
		}
	
	// Search Method

	chi = search(num, x, y, dy, funpointer, npar, a, step, anew);

	// Find approximate errors
	for(i=0; i<npar; i++)
		{
		if( step[i] > 0)
			{
			anew[i] += step[i];
			ch0 = chisq( num, x, y, dy, funpointer, anew);
			anew[i] -= 2*step[i];
			ch1 = chisq( num, x, y, dy, funpointer, anew);
			anew[i] += step[i];
			tmp = (ch1+ch0)/2.0 - chi;
			if(tmp > 0.0)
				danew[i] = step[i]/sqrt((ch1+ch0)/2.0-chi);
			else
				danew[i] = 0.;
			}
		else
			{
			danew[i] = 0.;
			}
		}
	redo = 0;
	if(DEBUG)
		{
		printf("\nNew Parameters:\n");
		for(i=0; i<npar; i++)
			{
			printf("anew[%d] = %g +- %g\n", i, anew[i], danew[i]);
			}
		}
	for(i=0; i<npar; i++)
		{
		if(step[i] > danew[i] && danew[i] > 0.)
			{
			redo = 1;
			step[i] = danew[i]/3.0;
			}
		}
	redchi = chi/(num - numpar);
	if(DEBUG)
		{
		printf("Chi-squared now = %g\n", chi);
		printf("Reduced chi-squared = %g\n", redchi);
		}

	// find if we need to redo
	if(redo)
		{
		for(i=0; i<npar; i++)
			a[i] = anew[i];
		if(DEBUG)printf("\nNew Iteration:");
		}
	} while(redo);
	

	if(DEBUG)
		{
		// Find the maximum and minimum x
		xmax = x[0];
		xmin = x[0];
		for(i=1; i<num; i++)
			{
			if(x[i] > xmax) xmax = x[i];
			if(x[i] < xmin) xmin = x[i];
			}
	
		// Write a file with the fitted curve
		fp = fopen("fit.dat", "w");
		for(i=0; i <= NUMOUT; i++)
			{
			xout = xmin + (xmax - xmin) / NUMOUT * i;
			yout = funpointer(xout, anew);
			fprintf(fp, "%g\t%g\n", xout, yout);
			}
		fclose(fp);
		// Write the fitted parameters to a file
		fp = fopen("parameters", "w");
		for(i=0; i < npar; i++)
			{
			fprintf(fp, "%d %g %g\n",i, anew[i], danew[i]);
			}
		fprintf(fp,"%g\n", redchi);
		fclose(fp);
		}
	}

// Search method

double search(int num, double *x, double *y, double *dy,
	double (*funpointer) (), int npar, double *a, double *step,
	double *anew)
	{
	int i, j;

	double chi, chinew;
	int better;

	for(i=0; i<npar; i++) anew[i] = a[i];

	chi = chisq(num, x, y, dy, funpointer, anew);
	
	do
		{
		better = 0;
		for(i=0; i < npar; i++)
		  if(step[i] != 0)
			{
			anew[i] += step[i];
			chinew = chisq(num, x, y, dy, funpointer, anew);
			if(chinew < chi)
				{
				chi = chinew;
				better = 1;
				}
			else
				{
				anew[i] -= 2.0*step[i];
				chinew = chisq(num, x, y, dy, funpointer, anew);
				if(chinew < chi)
					{
					chi = chinew;
					step[i] = -step[i];
					better = 1;
					}
				else
					{
					anew[i] += step[i];
					}
				}
			}
		} while(better);
	
	for(i = 0; i < npar; i++) step[i] = fabs(step[i]);
	return(chi);
	}

double chisq( int num, double *x, double*y, double*dy,
	double (*funpointer) (), double *a)
	{
	int i;
	double chi, e;

	chi = 0;
	for(i=0; i < num; i++)
		{
		if( dy[i] > 0)
			{
			e = funpointer(x[i], a);
			chi += (y[i] - e)*(y[i] - e)/dy[i]/dy[i];
			}
		}
	return(chi);
	}
#undef NUMOUT
#undef DEBUG
/* (C) Copr. 1986-92 Numerical Recipes Software *t9,12. */
/*######################
## smooft.c
######################*/
/** From Num. Recipes in C, p. 515
 * Smooths an array y of n data points, with a window whose full 
 * width is of order pts neighboring points, a user supplied value.
 * y is modified. y should be dimensioned at least of length [1..np]
 * where np >= integral power of two >= n+2*pts.
 **/

#include <stdlib.h>  /* BDS */
#include <math.h>

void smooft(float buff[],int n,int pts)  /* BDS: changed *y to *buff */
{

  int nmin,m=2,mo2,k,j;
  float yn,y1,rn1,fac,cnst;
  float *ytemp, *y;                        /* BDS */

  void realft(float *data, unsigned long n, int isign);

  nmin=n+(int) (2.0*pts+0.5);
  while (m < nmin) m *= 2;


  /** BDS: allocate the new y buffer (of appropriate size) and copy the data over **/
  ytemp = malloc(m * sizeof(float));
  if(!ytemp) {
    fprintf(stderr,"Can't allocate space for ytemp.  Exiting...\n");
    exit(1);
  }
  memcpy(ytemp,buff,n * sizeof(float));
  for(k=n;k<m;k++)/* zero rest of array */
    ytemp[k]=0.0;
  y = ytemp-1;;   /* since the rest of the routine uses unit offset arrays */
  /** BDS: End of my addition **/

  cnst=(float)pts/(float)m;      /* BDS -- NRinC forgot to cast to float!?! */
  cnst=cnst*cnst;

  y1=y[1];
  yn=y[n];
  rn1=1.0/((float) (n-1));
  for(j=1;j<=n;j++)              /* remove any global linear trend */
    y[j] -= rn1 * (y1 *(n-j) + yn * (j-1));
  for(j=n+1;j<=m;j++) y[j]=0.0;  /* zero out tail of array */

  mo2= m / 2;

  realft(y,mo2,1);


  y[1] = y[1]/(float)mo2;
  fac=1.0;
  for(j=1;j<mo2;j++) {
    k=2*j+1;
    if(fac) {
      if( (fac=(1.0-cnst*j*j)/(float)mo2) < 0.0 ) fac=0.0;
      y[k]=fac * y[k];
      y[k+1]=fac * y[k+1];
    } else y[k+1]=y[k]=0.0;
  }
  if( (fac=(1.0-0.25*pts*pts)/(float)mo2) < 0.0 ) fac=0.0;
  y[2] *= fac;

  realft(y,mo2,-1);

  for(j=1;j<=n;j++)              /* re-apply the global linear trend */
    y[j] = 2.0*(y[j] + rn1 * (y1 * (n-j)+yn * (j-1)));  /* BDS -- added leading 2* */


  /** BDS: copy data back into original array **/
  memcpy(buff+1,y+1,n * sizeof(float));   /* since memcpy uses zero offset arrays */

  free(ytemp);
}

/*######################
  ## smoother.c
  ######################*/
/* Take an array of ints, y[0-n], and smooths the array in place
 * using the smoothing parameter/box pts.  The smoothed array is 
 * then multiplied by scale. */

#include <stdlib.h>
#include <stdio.h>

void smoother(unsigned int *y, int *n, int *pts, int *scale)
{
  int    i;
  float  *fb;
  void smooft(float *yb,int nn,int ppts);

  fb = malloc(*n * sizeof(float));
  if(!fb) {
    fprintf(stderr,"smoother: Can't allocate space for fb.  Exiting...\n");
    exit(1);
  }

  for(i=0;i<*n;i++)
    *(fb+i)=(float) *(y+i);

  smooft(fb-1,*n,*pts); /* -1 since NRinC routines use unit-offset arrays */

  for(i=0;i<*n;i++)
    if(*(fb+i) > 0.0)
      *(y+i)=(unsigned int) (*(fb+i) * *scale + 0.5);
    else
      *(fb+i)=0;

  free(fb);
}

/*######################
## spline.c
######################*/
#define NRANSI

void spline(float x[], float y[], int n, float yp1, float ypn, float y2[])
{
  int i,k;
  float p,qn,sig,un,*u;

  u=vector(1,n-1);
  if (yp1 > 0.99e30)
    y2[1]=u[1]=0.0;
  else {
    y2[1] = -0.5;
    u[1]=(3.0/(x[2]-x[1]))*((y[2]-y[1])/(x[2]-x[1])-yp1);
  }
  for (i=2;i<=n-1;i++) {
    sig=(x[i]-x[i-1])/(x[i+1]-x[i-1]);
    p=sig*y2[i-1]+2.0;
    y2[i]=(sig-1.0)/p;
    u[i]=(y[i+1]-y[i])/(x[i+1]-x[i]) - (y[i]-y[i-1])/(x[i]-x[i-1]);
    u[i]=(6.0*u[i]/(x[i+1]-x[i-1])-sig*u[i-1])/p;
  }
  if (ypn > 0.99e30)
    qn=un=0.0;
  else {
    qn=0.5;
    un=(3.0/(x[n]-x[n-1]))*(ypn-(y[n]-y[n-1])/(x[n]-x[n-1]));
  }
  y2[n]=(un-qn*u[n-1])/(qn*y2[n-1]+1.0);
  for (k=n-1;k>=1;k--)
    y2[k]=y2[k]*y2[k+1]+u[k];
  free_vector(u,1,n-1);
}
#undef NRANSI
/* (C) Copr. 1986-92 Numerical Recipes Software *t9,12. */
// This concatentates <string1> and <string2>
// and puts the output in <outputstring>
#include <stdio.h>

void
stringcat(char *outputstring, char *string1, char *string2)
{
	sprintf(outputstring, "%s%s", string1, string2);
}
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

void
writeped(peddir, fname, nrun, run_numbers, arsize, ped, sigma, error, num, offset)
  char fname[];
  char peddir[];
  long run_numbers[];
  long *nrun, *arsize;
  short offset[];
  float ped[], sigma[], error[], num[];
{
  FILE *fp;
  char directory[80];
  char filename[80];
  int i,j,k;
  struct stat dstat;

  /* Check the directory exists - if not create it */
  if( stat (peddir, &dstat) != 0)
     {
     if( mkdir( peddir, 0755) != 0 )
	{
	printf( "Writeped: Can't make directory '%s'.\n", peddir);
	return;
	}
      }
  if(*nrun == 1)
     sprintf(directory,"%s/pedestals.run%ld", peddir, run_numbers[0]);
  else
     sprintf(directory,"%s/pedestals.run%ld-%ld", peddir, run_numbers[0], run_numbers[*nrun-1]);
  /* directory may already exist, so stat for it first */
  if( stat( directory, &dstat) != 0)
      {
      if( mkdir( directory, 0755) != 0)
	{
        printf( "Writeped: Can't make directory '%s'.\n", directory);
	return;
        }
      }
  sprintf(filename,"%s/%s", directory, fname);
  if( (fp = fopen( filename, "w")) == NULL)
    {
    printf("Writeped: Can't open file '%s' for output\n",filename);
    return;
    }
  for(i=0; i< *arsize; i++)
    {
    fprintf(fp,"%.0f\n", ped[i]);
    }
  fclose(fp);
  sprintf(filename,"%s/%s.summary", directory, fname);
  if( (fp = fopen( filename, "w")) == NULL)
    {
    printf("Writeped: Can't open file '%s' for output\n",filename);
    return;
    }
  fprintf(fp, "Pedestals calculated from %d runs.\n",*nrun);
  fprintf(fp, "Run numbers: ");
  for(i=0; i<*nrun; i++) fprintf(fp, " %d", run_numbers[i]);
  fprintf(fp, "\n\n");
  fprintf(fp, "Pedestals for %s\n",fname);
  fprintf(fp, "    Channel  Pedestal     Error Std. Dev. Num. Used    Online Offset\n");
  for(i=0; i< *arsize; i++)
      {
      fprintf(fp, "%9d %9.0f %9.2f %9.1f %9.0f %9d ",i,ped[i],error[i],sigma[i],num[i],offset[i]); 
      if(fabs(ped[i] - offset[i]) > 2.*sigma[i]) fprintf(fp, "**");
      if(fabs(ped[i] - offset[i]) > 3.*sigma[i]) fprintf(fp, "*");
      if(fabs(ped[i] - offset[i]) > 4.*sigma[i]) fprintf(fp, "*");
      fprintf(fp, "\n");
      }
  fclose(fp);
}

#undef PED_DIR
